<html>

<head>
  <title>Form Validation Error Test</title>
  <script>
    // we load from localhost, and have the ability to
    // change the scripts that are being served. Check the
    // web-test-runner.config.js file for details
    window.RUM_BASE = window.origin;
    // we log what's being sent to the "server"
    window.called = [];
    // and navigator.sendBeacon has been replaced with
    // a call to fakeSendBeacon
    window.fakeSendBeacon = function (url, payload) {
      // if payload is a string, we assume it's a JSON string
      if (typeof payload === 'string') {
        window.called.push(JSON.parse(payload));
      } else {
        // it's a blob
        payload.text().then((text) => {
          window.called.push(JSON.parse(text));
        });
      }
    };
  </script>
  <script defer type="text/javascript" src="/.rum/@adobe/helix-rum-js@^2/dist/rum-standalone.js"></script>
</head>

<body>
  <div class="block" data-block-status="loaded">
    <h2>Form Validation Error Tests</h2>
    
    <!-- Test 1: Required field validation -->
    <form id="required-form" action="javascript:false;" method="POST">
      <input type="text" name="username" required placeholder="Username (required)">
      <input type="email" name="email" required placeholder="Email (required)">
      <input type="submit" value="Submit Required Form">
    </form>

    <!-- Test 2: Email format validation -->
    <form id="email-form" action="javascript:false;" method="POST">
      <input type="email" name="email" value="invalid-email" placeholder="Email">
      <input type="submit" value="Submit Email Form">
    </form>

    <!-- Test 3: Pattern validation -->
    <form id="pattern-form" action="javascript:false;" method="POST">
      <input type="text" name="phone" pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}" value="123" placeholder="Phone (XXX-XXX-XXXX)">
      <input type="submit" value="Submit Pattern Form">
    </form>

    <!-- Test 4: Length validation -->
    <form id="length-form" action="javascript:false;" method="POST">
      <input type="text" name="short" minlength="5" value="hi" placeholder="Min 5 chars">
      <input type="text" name="long" maxlength="3" value="toolong" placeholder="Max 3 chars">
      <input type="submit" value="Submit Length Form">
    </form>

    <!-- Test 5: Range validation -->
    <form id="range-form" action="javascript:false;" method="POST">
      <input type="number" name="age" min="18" max="100" value="15" placeholder="Age (18-100)">
      <input type="submit" value="Submit Range Form">
    </form>

    <!-- Test 6: Valid form (no errors) -->
    <form id="valid-form" action="javascript:false;" method="POST">
      <input type="text" name="name" value="John Doe" placeholder="Name">
      <input type="email" name="email" value="john@example.com" placeholder="Email">
      <input type="submit" value="Submit Valid Form">
    </form>

    <script>
      // Prevent form submission for testing
      document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
        });
      });
    </script>
  </div>

  <script type="module">
    import { runTests } from '@web/test-runner-mocha';
    import { sendMouse, setViewport } from '@web/test-runner-commands';
    import { assert } from '@esm-bundle/chai';

    runTests(async () => {
      describe('Form Validation Error Tracking', () => {
        
        beforeEach(() => {
          // Clear previous calls before each test
          window.called = [];
        });

        it('Should track valueMissing validation errors', async function test() {
          const form = document.querySelector('#required-form');
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit form with empty required fields
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check for error checkpoints
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          assert(errorCalls.length >= 2, 'Should have at least 2 validation errors');
          
          // Check for valueMissing errors
          const valueMissingErrors = errorCalls.filter(call => call.target === 'valueMissing');
          assert(valueMissingErrors.length >= 2, 'Should have valueMissing errors for required fields');
        });

        it('Should track typeMismatch validation errors', async function test() {
          const form = document.querySelector('#email-form');
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit form with invalid email format
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check for typeMismatch error
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          const typeMismatchErrors = errorCalls.filter(call => call.target === 'typeMismatch');
          assert(typeMismatchErrors.length >= 1, 'Should have typeMismatch error for invalid email');
        });

        it('Should track patternMismatch validation errors', async function test() {
          const form = document.querySelector('#pattern-form');
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit form with invalid pattern
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check for patternMismatch error
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          const patternMismatchErrors = errorCalls.filter(call => call.target === 'patternMismatch');
          assert(patternMismatchErrors.length >= 1, 'Should have patternMismatch error for invalid phone pattern');
        });

        it('Should track tooShort and tooLong validation errors', async function test() {
          const form = document.querySelector('#length-form');
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit form with length validation errors
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check for length validation errors
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          const tooShortErrors = errorCalls.filter(call => call.target === 'tooShort');
          const tooLongErrors = errorCalls.filter(call => call.target === 'tooLong');
          
          assert(tooShortErrors.length >= 1, 'Should have tooShort error for field below minlength');
          assert(tooLongErrors.length >= 1, 'Should have tooLong error for field above maxlength');
        });

        it('Should track rangeUnderflow validation errors', async function test() {
          const form = document.querySelector('#range-form');
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit form with value below minimum
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check for rangeUnderflow error
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          const rangeUnderflowErrors = errorCalls.filter(call => call.target === 'rangeUnderflow');
          assert(rangeUnderflowErrors.length >= 1, 'Should have rangeUnderflow error for value below minimum');
        });

        it('Should not track errors for valid forms', async function test() {
          const form = document.querySelector('#valid-form');
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit valid form
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check that no error checkpoints were sent
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          assert(errorCalls.length === 0, 'Should not have error checkpoints for valid form');
          
          // But should still have form submit checkpoint
          const submitCalls = window.called.filter(call => call.checkpoint === 'formsubmit');
          assert(submitCalls.length >= 1, 'Should still have formsubmit checkpoint for valid form');
        });

        it('Should track multiple validation errors on single form', async function test() {
          const form = document.querySelector('#required-form');
          
          // Add more validation errors to the form
          const emailInput = form.querySelector('input[name="email"]');
          emailInput.value = 'invalid-email-format';
          
          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Submit form with multiple validation errors
          form.querySelector('input[type="submit"]').click();

          await new Promise((resolve) => {
            setTimeout(resolve, 2000);
          });

          // Check for multiple error types
          const errorCalls = window.called.filter(call => call.checkpoint === 'error');
          assert(errorCalls.length >= 2, 'Should have multiple validation errors');
          
          const errorTypes = errorCalls.map(call => call.target);
          assert(errorTypes.includes('valueMissing'), 'Should include valueMissing error');
          assert(errorTypes.includes('typeMismatch'), 'Should include typeMismatch error');
        });

      });
    });
  </script>
</body>

</html>
